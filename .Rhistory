mtcarsplus <- rbind(mtcars, spacecar)
mtcars.countryplus <- c(mtcars.country, "Jupiter")
mtcarsplus.pca <- prcomp(mtcarsplus[,c(1:7,10,11)], center = TRUE,scale. = TRUE)
mtcars.pca$center
s.sc <- scale(t(spacecar[c(1:7,10,11)]), center= mtcars.pca$center)
s.pred <- s.sc %*% mtcars.pca$rotation
s.sc
s.pred
mtcars.pca$rotation
s.sc
s.sc
mtcars.pca$rotation
mtcars.plusproj.pca <- mtcars.pca
mtcars.plusproj.pca
mtcars.plusproj.pca$x
mtcars.plusproj.pca$x <- rbind(mtcars.plusproj.pca$x, s.pred)
library(data.table)
?fred
?fread
?wread
84*0.15
library(SNPRelate)
library(SNPRelate)
library(SeqArray)
?snpgdsBED2GDS
?snpgdsSummary
?seqSNP2GDS
1000000*162041/4
1000000*162041/4/1021/1021/1021
1000000*162041/4/1021/1021/1021-38
0.06165751*1021
15/52*2*1000
52*7
150000/26
1069863*2
2139732-6
806*805/2
?svydesign
??
svydesign
library(survey)
install.packages("survey")
library(survey)
?surveydesign
?svydesign
4400000/88/2
793*792/2
127/12
1075011/25
25+50
55/75
check <- seq(0,1,by=0.001)
check
for (i in check){
min(0.01,i/5,(1-i)/5)
}
for (i in check){
print(min(0.01,i/5,(1-i)/5))
}
temp <- 0
for (i in check){
temp <- c(temp,(min(0.01,i/5,(1-i)/5)))
}
temp
temp2 <- temp[-1]
temp2
summary(temp2)
check <- seq(0.05,1,by=0.001)
temp <- NULL
for (i in check){
temp <- c(temp,(min(0.01,i/5,(1-i)/5)))
}
temp
summary(temp)
check <- seq(0.05,0.5,by=0.001)
temp <- NULL
for (i in check){
temp <- c(temp,(min(0.01,i/5,(1-i)/5)))
}
summary(temp)
temp
summary(temp)
check <- seq(0.05,1,by=0.001)
temp <- NULL
for (i in check){
temp <- c(temp,min(0.01, i/5,(1-i)/5))
}
summary(temp)
check <- seq(0.05,1,by=0.001)
temp.max <- NULL
temp.min <- NULL
for (i in check){
temp.min <- c(temp.min,min(0.01, i/5))
temp.max <- c(temp.max,min(0.01, i/5,(1-i)/5))
}
temp <- cbind(temp.min,temp.max)
head(temp)
check <- seq(0.05,1,by=0.001)
temp.max <- NULL
temp.min <- NULL
for (i in check){
temp.min <- c(temp.min,i-min(0.01, i/5))
temp.max <- c(temp.max,i+min(0.01, i/5,(1-i)/5))
}
temp <- cbind(temp.min,temp.max)
head(temp)
View(temp)
print(temp)
temp <- 0
for (i in 1:100){
temp <- temp + i^3
print(temp)
}
check <- cbind(1:100, temp)
check
temp <- 0
check <- NULL
for (i in 1:100){
temp <- temp + i^3
temprow <- c(i, temp)
check <- rbind(check,temprow)
}
check
25502500-24502500
log(1.702)
log(1.367)
log10
log(10)
log10(10)
log10(100)
log10(1.367)
log10(1.702)
log10(1.367)*2+log10(1.702)*2
log10(1.367)*1+log10(1.702)*1
log10(1.367)*1+log10(1.702)*2
log10(1.367)*2+log10(1.702)*1
log(1.367)*2+log(1.702)*1
log(1.367)*+log(1.702)*2
log(1.367)*1+log(1.702)*2
0.7334561/(1+0.7334561)
250*.09
16000+9300
3700-959
3700-959-1000
library(synbreed)
library(synbreed)
peda <- simul.pedigree(gener=4,ids=c(3,5,8,8),animals=TRUE)
plot(peda)
peda <- simul.pedigree(gener=4,ids=c(3,5,8,8))
peda <- simul.pedigree(gener=4,ids=c(3,5,8,8))
plot(peda)
?simul.pedigree
peda <- simul.pedigree(generations = 2, ids = 4, animals=FALSE,familySize=1)
plot(peda)
peda <- simul.pedigree(generations = 2, ids = 4, animals=TRUE,familySize=1)
plot(peda)
peda <- simul.pedigree(generations = 2, ids = c(4,2), animals=TRUE,familySize=1)
plot(peda)
peda <- simul.pedigree(generations = 2, ids = c(4,4), animals=TRUE,familySize=1)
plot(peda)
200*14
99*14
220*14
library(e1071)
?tune
13354*2
959*2+110
check <- c("1196", "778", "325", "9989", "427")
sum(check)
check <- c(1196, 778, 325, 9989, 427)
sum(check)
check/sum(check)
check/sum(check)*100
round(check/sum(check)*100,2)
round(check/sum(check)*100,1)
100*137*0.9
45/(27+7)*7+4.5/2
45/(27*2+7)*7+4.5/2
45/27*7/2+4.5/2
-0.6122*8.1655
0.0523*2.3074
5*0.8141-0.120677*0.5805
-5*0.5805+0.120677*0.8142
a <- matrix(4,2,c(4,3,2,2,-1,-3,-5,-2))
a
?matrix
a <- matrix(4,2, byrow = TRUE,c(4,3,2,2,-1,-3,-5,-2))
a
a <- matrix(c(4,3,2,2,-1,-3,-5,-2),4,2, byrow = TRUE)
a
check <- svd(a)
names(check)
check$d
check$u
check$v
set.seed(1234)     # for reproducibility
x <- rnorm(10)     # standard normal
x
?standardize
??standardize
?scale
x <- matrix(1:10, ncol = 2)
x
scale(x)
scale(x, scale=FALSE)
?svd
check <- scale(x, scale=FALSE)
check
x
tans(x)
t(x)
x^-1
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- x2$d
vt <- x2$v
x*t(vt)*t(s)
x*t(vt)*(s^-1)
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- x2$d
u <- x2$u
v <- x2$v
x*t(vt)*(s^-1)
dim(x)
dim(vt)
dim(s)
s
x*t(vt)*(s^-2)
x*t(vt)
t(vt)
x
x*t(vt)
x*vt
class(x)
class*(vt)
class(vt)
x*vt
x %*% vt
x %*% vt %*% (s^-2)
u
x %*% vt %*% (s^-1)
u
x %*% t(vt) %*% (s^-1)
x %*% v %*% (s^-1)
x %*% v %*% (s^-2)
v
x2 %*% v %*% (s^-2)
x %*% v %*% t(s)
x2 <- svd(x)
s <- x2$d
u <- x2$u
v <- x2$v
x %*% v %*% t(s)
x %*% v %*% s^-2
u
t(x) %*% x
v %*% s^2 %*% t(x)
?%*%
?%*%
%*%
v %*% s %*% s %*% t(x)
v %*% (s %*% s) %*% t(x)
v %*% s %*% s %*% t(x)
t(x) %*% x
v %*% s %*% s %*% t(v)
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- x2$d
u <- x2$u
v <- x2$v
t(x) %*% x
v %*% s %*% s %*% t(v)
v
t(v)
t(v) %*% s %*% s %*% (v)
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- x2$d
u <- x2$u
v <- x2$v
u %*% s %*% v
u %*% s %*% t(v)
x
u %*% s
v
u
s
diag(s)
u %*% diag(s) %*% t(v)
u %*% s %*% t(v)
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- x2$d
u <- x2$u
v <- x2$v
u %*% diag(s) %*% t(v)
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
u %*% s %*% t(v)
x
t(x) %*% x
v %*% s %*% s %*% t(v)
u
v %*% s^-2
x %*% v %*% t(s)
u
x %*% v %*% (s^-2)
v %*% s %*% s %*% t(v)
t(x) %*% x
(s^-2)
x %*% v %*% (s^-2)
(x2$d)^2
x %*% v %*% diag((x2$d)^2)
x %*% v %*% diag((x2$d)^-22)
x %*% v %*% diag((x2$d)^-2)
u
x %*% v %*% diag((x2$d)^-1)
x %*% v %*% diag((x2$d)^-1)
u
uu <- x %*% v %*% diag((x2$d)^-1)
uu==u
s <- diag(x2$d)
s
t(s)
u
x
u
u <- x2$u
u
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
u
t(u) %*% u
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
x %*% v %*% t(s)
u
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
x
u %*% s %*% t(v)
u
x %*% v  %*% s^-1
(s^-1)
s
diag(s^-1)
s^-1
x2$d
x2$d^-1
diag(x2$d^-1)
x %*% v  %*% diag(x2$d^-1)
u
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
v
t(v)
t(v) %*% v
t(v)
v^-1
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
u %*% s %*% t(v)
U
u
s
solve(s)
s %*% solve(s)
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
u %*% s %*% t(v)
u
solve(s)
s
19.53779^-1
x %*% v  %*% solve(s)
u
u==x %*% v  %*% solve(s)
?scale
?mds
x <- matrix(1:10, ncol = 2)
x2 <- svd(x)
s <- diag(x2$d)
u <- x2$u
v <- x2$v
u %*% s %*% t(v)
x %*% v  %*% solve(s)
x %*% v  %*% solve(s)
x
v
setwd("~/Documents/2019_ASHG/test_git/R")
library(e1071)
prefix = "ex"
pc <- read.table(paste0(prefix, "pc.txt"), header = TRUE)
phe <- read.table(paste0(prefix, "_popref.txt"), header = TRUE)
print(paste("Prepare the PC file and the reference file, starts at ", date()))
pop <- phe[, c("IID", "Population")]
train.data <- pc[pc$AFF == 1, c(2, 7:16)]
train.phe <- merge(train.data, pop, by = "IID")
test.data <- pc[pc$AFF == 2, c(1, 2, 7:16)]
train.x <- train.phe[, !colnames(train.phe) %in% c("Population", "IID")]
train.y <- train.phe[, "Population"]
if (require("doParallel", quietly = TRUE)) {
numCores <- detectCores()
registerDoParallel(cores = min(round(numCores/2), 41))
tuneresults <- function(cost) {
tuneresult <- foreach(cost = cost, .combine = c) %dopar% {
set.seed(123)
mod = tune(svm, train.x, as.factor(train.y), kernel = "linear", cost = cost,
probability = TRUE)
mod$performances[, c("error")]
}
best.cost <- cost[which.min(tuneresult)]
return(best.cost)
}
} else {
numCores <- 2
tuneresults <- function(cost){
set.seed(123)
tune.mod <- tune(svm, train.x, as.factor(train.y), kernel = "linear", ranges=(list(cost=cost)),
probability = TRUE)
return(tune.mod$best.parameters[1,1])
}
}
print(paste0("Assign ", min(round(numCores/2), 41), " cores for the grid search."))
print(paste("Grid search with a wide range, starts at", date()))
best.cost <- tuneresults(2^(seq(-10, 10, by = 0.5)))
print(paste("Grid search with a wide range, ends at", date()))
print(paste0("The best cost is ", round(best.cost, 6), " after the wide grid search"))
print(paste("Grid search with a small range, starts at", date()))
more.cost <- 2^seq(log2(best.cost) - 0.5, log2(best.cost) + 0.5, by = 0.05)
best.cost <- tuneresults(more.cost)
print(paste("Grid search with a small range, ends at", date()))
print(paste0("The best cost is ", round(best.cost, 6), " after the small grid search"))
set.seed(123)
mymod <- svm(train.x, as.factor(train.y), cost = best.cost, kernel = "linear", probability = TRUE)
print(paste("Predict ancestry information, start at", date()))
pred.pop <- predict(mymod, test.data[, !colnames(test.data) %in% c("FID", "IID")], probability = TRUE)
test.data$PRED <- pred.pop
class.prob <- attr(pred.pop, "probabilities")
print(paste("Prepare the summary file, starts at", date()))
orders <- t(apply(class.prob, 1, function(x) order(x, decreasing = T)))
orders.class <- t(apply(orders, 1, function(x) colnames(class.prob)[x]))
orders.probs <- t(sapply(1:nrow(class.prob), function(x) class.prob[x, orders[x, ]]))
check.cumsum <- t(apply(orders.probs, 1, cumsum))
temp <- apply(check.cumsum, 1, function(x) which(x > 0.65)[1])
pred.class <- sapply(1:length(temp), function(x) paste(orders.class[x, 1:as.numeric(temp[x])], collapse = ";"))
pred.prob <- sapply(1:length(temp), function(x) paste(round(orders.probs[x, 1:as.numeric(temp[x])], 3), collapse = ";"))
pred.out <- cbind(test.data[, c("FID", "IID", "PC1", "PC2")], pred.class, pred.prob,
orders.class[, 1], orders.class[, 2], round(orders.probs[, 1], 3), round(orders.probs[, 2],3))
colnames(pred.out)[5:10] <- c("Ancestry", "Pr_Anc", "Anc_1st", "Anc_2nd", "Pr_1st", "Pr_2nd")
print(paste("summary file is ready ", date()))
write.table(pred.out, paste0(prefix, "_InferredAncestry.txt"), quote = FALSE, row.names = FALSE)
print(paste("Results are saved to", paste0(prefix, "_InferredAncestry.txt")))
print("Generate plots")
pred.out$Ancestry <- as.character(pred.out$Ancestry)
pred.out$Ancestry[pred.out$Pr_1st <= 0.65] <- ">1 Pop"
Palette <- c("#1F78B4", "#33A02C", "#E31A1C", "#FF7F00", "#6A3D9A", "#B15928", "#A6CEE3",
"#B2DF8A", "#FB9A99", "#FDBF6F", "#CAB2D6", "#FFFF99", "#999999")
train.groups <- unique(train.phe$Population)
pred.colors <- rep(Palette[13], nrow(pred.out))
for (i in 1:length(train.groups)) {
pred.colors[pred.out$Ancestry == train.groups[i]] <- Palette[i]
}
train.colors <- rep(0, nrow(train.phe))
for (i in 1:length(train.groups)) {
train.colors[train.phe$Population == train.groups[i]] <- Palette[i]
}
x.adjust <- (max(train.phe$PC1, pred.out$PC1) - min(train.phe$PC1, pred.out$PC1))/10
x.low <- min(train.phe$PC1, pred.out$PC1) - x.adjust
x.high <- max(train.phe$PC1, pred.out$PC1) + x.adjust
y.adjust <- (max(train.phe$PC2, pred.out$PC2) - min(train.phe$PC2, pred.out$PC2))/10
y.low <- min(train.phe$PC2, pred.out$PC2) - y.adjust
y.high <- max(train.phe$PC2, pred.out$PC2) + y.adjust
postscript(paste0(prefix, "_ancestryplot.ps"), paper = "letter", horizontal = T)
ncols <- min(3, ceiling(length(unique(pred.out$Ancestry))/2))
plot(pred.out$PC1, pred.out$PC2, col = pred.colors, xlab = "PC1", ylab = "PC2", xlim = c(x.low, x.high),
ylim = c(y.low, y.high), main = paste("Inferred Populations as Ancestry in", prefix), pch = 16)
legend("topright", legend = sort(unique(pred.out$Ancestry)), col = unique(pred.colors)[order(unique(pred.out$Ancestry))], pch = 16, cex = 1)
par(mfrow = c(2, ncols))
for (i in sort(unique(pred.out$Ancestry))) {
subdata <- subset(pred.out, Ancestry == i)
plot(subdata$PC1, subdata$PC2, col = unique(pred.colors)[unique(pred.out$Ancestry) == i],
xlim = c(x.low, x.high), ylim = c(y.low, y.high), xlab = "PC1", ylab = "PC2",
main = paste0(i, " (N=", nrow(subdata), ")"))
}
par(mfrow = c(1, 1))
plot(train.phe$PC1, train.phe$PC2, col = train.colors, xlim = c(x.low, x.high),
ylim = c(y.low, y.high), xlab = "PC1", ylab = "PC2", main = "Populations in Reference", pch = 16)
legend("topright", legend = sort(unique(train.phe$Population)),
col = unique(train.colors)[order(unique(train.phe$Population))], pch = 16, cex = 1)
